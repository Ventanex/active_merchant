continue
request
continue
request
continue
exit
amount(nil)
amount(money)
money.blank?
money
continue
request
continue
request
live_url + '/SvcInfo/token'
live_url + "/Txn/#{@work_flow_id}"
@work_flow_id
continue
request
continue
Hash.from_xml(request)
request.to_str
request.to_string
request.to_strint
request
continue
request
continue
request
continue
                :year               => Time.now.year+1,
                :month              => '8',
                :number             => '4242424242424242',
                :last_name          => 'Bobsen',
                :first_name         => 'Bob',
credit_card = ActiveMerchant::Billing::CreditCard.new(
request
continue
response = hash.deep_transform_keys { |k| k.to_s.underscore.to_sym }.except(:xmlns, :"xmlns:i", :addendum)
response = hash.deep_transform_keys { |k| k.to_s.underscore.to_sym }.except(:xmlns, :"xmlns:i", :unmanaged)
response = hash.deep_transform_keys { |k| k.to_s.underscore.to_sym }.except(:xmlns, :"xmlns:i")
response = hash.deep_transform_keys { |k| k.to_s.underscore.to_sym }.except(:xmlns, :"xmlns:1")
response = hash.deep_transform_keys { |k| k.to_s.underscore.to_sym }.except(:xmlns, :"xmlns:1"))
response = hash.deep_transform_keys { |k| k.to_s.underscore.to_sym }.except(:xmlns)
response = hash.deep_transform_keys { |k| k.to_s.underscore.to_sym }
response = hash.transform_keys { |k| k.to_s.underscore.to_sym }
hash = Hash.from_xml(body)['BankcardTransactionResponsePro']
hash.transform_keys { |key| key.to_s.underscore.to_sym }
hash.transform_keys { |key| key.to_s.underscore }
hash.symbolize_keys!
hash = Hash.from_xml(body)
h
h = Hash.from_xml(body)
Hash.from_xml(body)
response
continue
response
continue
response
exit
doc = Nokogiri::XML(body)
body
doc.at_xpath("//BankcardTransactionResponsePro/StatusCode")
response
exit
response
exit
response
exit
doc.at_xpath("//MaskedPAN").content[-4..-1]
doc.at_xpath("//MaskedPAN")
doc.at_xpath("//AVSResult").content
doc.at_xpath("//AVSResult")
doc.at_xpath("//avsResultCode")
doc.at_xpath("//BankcardTransactionResponsePro/Status").content
doc.at_xpath("//BankcardTransactionResponsePro/Status")
response.at_xpath("//BankcardTransactionResponsePro/Status")
response
doc
response
doc.at_xpath("/BankcardTransactionResponsePro/Status/text()")
doc.at_xpath('/BankcardTransactionResponsePro/Status/text()').content
doc.at_xpath('/BankcardTransactionResponsePro/Status/text()').text
doc.at_xpath('/BankcardTransactionResponsePro/Status/text()').values
doc.at_xpath('/BankcardTransactionResponsePro/Status/text()').value
doc.at_xpath('/BankcardTransactionResponsePro/Status/text()')
doc.remove_namespaces!
doc = Nokogiri::XML(response)
doc = Nokogiri::XML(response_)
require 'nori'
Nori
xml.to_h
xml.to_hash
xml.remove_namespaces!
xml = Nokogiri::XML(response)
msg
response
msg = REXML::Document.new(response)
response
continue
ssl_post(live_url + "/Txn/#{@work_flow_id}", post_data(action, parameters), headers)
post_data(action, parameters)
exit
parameters
post_data(action, parameters)
post_data
exit
parameters
ssl_post(live_url + "/Txn/#{@work_flow_id}", post_data(action, parameters), headers)
continue
headers
exit
parameters
headers
live_url + "/Txn/#{@work_flow_id}"
live_url + '/SvcInfo/token'
doc.to_xml
doc = Nokogiri::XML authorize_xml(parameters).to_xml
authorize_xml(parameters).to_xml
authorize_xml(parameters)
post_data(action, parameters)
continue
post_data(action, parameters).to_xml
post_data(action, parameters)
post_data
response
response = ssl_post(live_url + "/Txn/#{@work_flow_id}", post_data(action, parameters), headers)
live_url + "/Txn/#{@work_flow_id}"
ssl_post(live_url + "/Txn/#{@work_flow_id}", post_data(action, parameters), headers)
continue
 post_data(action, parameters)
ssl_post(live_url + '/Txn', post_data(action, parameters), headers)
exit
ssl_post(live_url + '/Txn', post_data(action, parameters), headers)
post_data(action, parameters)
continue
post_data(action, parameters)
exit
exi
raw_ssl_request(:post, live_url + '/Txn', parameters, headers)
raw_ssl_request(:post, live_url + '/Txn', post_data(action, parameters), headers)
post_data(action, parameters)
ssl_post(live_url + '/Txn', post_data(action, parameters), headers)
response = parse(ssl_post(live_url + '/Txn', post_data(action, parameters), headers))
headers
post_data(action, parameters)
live_url + '/Txn'
exit
post_data(action, parameters)
parameters
continue
post_data(action, parameters)
parameters
action
headers
exit
Base64.strict_encode64(str.gsub(/"/, '').concat(":"))
str = token
token
token = ssl_get(AUTH_URL, headers)
ssl_get(AUTH_URL, headers)
headers = { "Content-Type" => "application/json", "Authorization" => "Basic #{Base64.strict_encode64(@identity_token.gsub(/"/, '').concat(":"))}" }
AUTH_URL
irb
response
continue
parse(ssl_post(live_url, post_data(action, parameters)))
live_url
post_data(action, parameters)
parameters
